name: Generate Blog Hero Images

on:
  workflow_dispatch:
    inputs:
      start_week:
        description: "Start week number (1–52)"
        required: true
        default: "1"
      end_week:
        description: "End week number (1–52)"
        required: true
        default: "1"
      overwrite:
        description: "Overwrite existing images (true/false)"
        required: true
        default: "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  generate-images:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          npm init -y
          npm install openai@^4 sharp cheerio

      - name: Generate images + update blog hero img src/alt
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          START_WEEK: ${{ github.event.inputs.start_week }}
          END_WEEK: ${{ github.event.inputs.end_week }}
          OVERWRITE: ${{ github.event.inputs.overwrite }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const cheerio = require("cheerio");
          const sharp = require("sharp");
          const OpenAI = require("openai");

          if (!process.env.OPENAI_API_KEY) {
            console.error("Missing OPENAI_API_KEY secret.");
            process.exit(1);
          }

          const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

          const clampInt = (v, min, max) => {
            const n = Number(String(v).trim());
            if (!Number.isFinite(n)) return min;
            return Math.max(min, Math.min(max, Math.floor(n)));
          };

          const startWeek = clampInt(process.env.START_WEEK, 1, 52);
          const endWeek = clampInt(process.env.END_WEEK, 1, 52);
          const overwrite = String(process.env.OVERWRITE).toLowerCase() === "true";

          const lo = Math.min(startWeek, endWeek);
          const hi = Math.max(startWeek, endWeek);

          const blogDir = path.join(process.cwd(), "blog");
          const outDir = path.join(process.cwd(), "assets", "blog-hero");
          fs.mkdirSync(outDir, { recursive: true });

          const pad2 = (n) => String(n).padStart(2, "0");

          function pickHeroImg($) {
            const candidates = [
              "figure img",
              ".post-hero img",
              ".hero img",
              "header img",
              "main img",
              "img"
            ];
            for (const sel of candidates) {
              const el = $(sel).first();
              if (el && el.length) return el;
            }
            return null;
          }

          function getTitle($) {
            return (
              ($("h1").first().text() || "").trim() ||
              ($("title").text() || "").trim() ||
              `Spin Wheel Deals Blog`
            );
          }

          function getMetaDescription($) {
            return ($('meta[name="description"]').attr("content") || "").trim();
          }

          function extractMainText($) {
            // Remove noisy elements
            $("script, style, noscript, nav, footer, header, aside").remove();

            // Prefer main/article content if present
            let text = "";
            const main = $("main").first();
            const article = $("article").first();

            if (article && article.length) {
              text = article.text();
            } else if (main && main.length) {
              text = main.text();
            } else {
              text = $("body").text();
            }

            // Normalize whitespace
            text = String(text || "")
              .replace(/\s+/g, " ")
              .trim();

            // Keep enough for theme understanding but not huge
            // (We do NOT print/log this content.)
            const MAX = 3500;
            if (text.length > MAX) text = text.slice(0, MAX).trim() + "…";
            return text;
          }

          async function sleep(ms) {
            return new Promise((r) => setTimeout(r, ms));
          }

          function safeJsonParse(s) {
            try {
              return JSON.parse(s);
            } catch (e) {
              return null;
            }
          }

          async function createVisualBrief({ title, metaDesc, bodyText }) {
            // Ask a text model to extract a structured “visual brief” + keywords from the blog.
            // We keep this short, consistent, and machine-parsable.
            const prompt = `
You are generating a visual brief for a blog hero image.

Return ONLY valid JSON with these keys:
{
  "visual_concept": "1 sentence describing what the image should show",
  "subjects": ["short list of key subjects/objects"],
  "setting": "short setting description",
  "mood": "short mood words",
  "palette": "short color palette guidance",
  "keywords": ["5-12 keywords"],
  "alt": "accessibility alt text describing the image"
}

Rules:
- No brand names, no logos, no text in the image.
- Keep it evergreen and dog-related.
- Prefer items that match the post topic.
- Be specific enough for an image model.

BLOG TITLE:
${title}

META DESCRIPTION (if any):
${metaDesc || "(none)"}

BLOG BODY (truncated):
${bodyText}
`.trim();

            const resp = await client.chat.completions.create({
              model: "gpt-4o-mini",
              temperature: 0.4,
              messages: [
                { role: "system", content: "You are a careful JSON-only generator." },
                { role: "user", content: prompt }
              ]
            });

            const raw = resp?.choices?.[0]?.message?.content || "";
            const json = safeJsonParse(raw);

            if (json && json.visual_concept && json.keywords && json.alt) {
              return json;
            }

            // Fallback: if parsing fails, fall back to a simple brief
            return {
              visual_concept: `A friendly, modern illustration that fits the topic: ${title}`,
              subjects: ["dog", "toy"],
              setting: "clean studio-like background with soft gradients",
              mood: "friendly, upbeat, trustworthy",
              palette: "cool blues/teals with subtle warm accents",
              keywords: [title].filter(Boolean),
              alt: `Illustration for blog post: ${title}`
            };
          }

          function buildImagePromptFromBrief(brief) {
            const subjects = Array.isArray(brief.subjects) ? brief.subjects.join(", ") : "";
            const keywords = Array.isArray(brief.keywords) ? brief.keywords.join(", ") : "";

            return [
              "Create a clean, modern hero image for a blog post about dogs and dog toys/training/health.",
              "Style: friendly, semi-realistic illustration (not a photo), soft lighting, smooth gradients, high clarity.",
              "No text, no letters, no watermarks, no logos, no brand marks.",
              "Keep it evergreen and family-friendly.",
              brief.visual_concept ? `Visual concept: ${brief.visual_concept}` : "",
              subjects ? `Include these subjects: ${subjects}` : "",
              brief.setting ? `Setting: ${brief.setting}` : "",
              brief.mood ? `Mood: ${brief.mood}` : "",
              brief.palette ? `Color palette: ${brief.palette}` : "",
              keywords ? `Topic keywords: ${keywords}` : "",
              "Composition: centered subject with generous negative space, suitable as a wide header image.",
              "Avoid: frightening imagery, aggressive dogs, gore, harsh neon, busy clutter."
            ].filter(Boolean).join("\n");
          }

          async function generateHeroPng(prompt) {
            const res = await client.images.generate({
              model: "gpt-image-1-mini",
              prompt,
              size: "1536x1024",
              quality: "low"
            });
            const b64 = res?.data?.[0]?.b64_json;
            if (!b64) throw new Error("No b64_json returned from image generation.");
            return Buffer.from(b64, "base64");
          }

          function toWebpPadded(inputPngBuffer, width, height) {
            return sharp(inputPngBuffer)
              .resize(width, height, {
                fit: "contain",
                background: { r: 0, g: 0, b: 0, alpha: 0 }
              })
              .webp({ quality: 82 })
              .toBuffer();
          }

          (async () => {
            console.log(`Generating hero images for weeks ${lo}–${hi} (overwrite=${overwrite})`);
            const changedFiles = [];

            for (let week = lo; week <= hi; week++) {
              const file = `week-${pad2(week)}.html`;
              const blogPath = path.join(blogDir, file);

              if (!fs.existsSync(blogPath)) {
                console.warn(`Skip: ${blogPath} not found`);
                continue;
              }

              const html = fs.readFileSync(blogPath, "utf8");
              const $ = cheerio.load(html);

              const title = getTitle($);
              const metaDesc = getMetaDescription($);
              const bodyText = extractMainText($);

              const outName = `week-${pad2(week)}.webp`;
              const outPath = path.join(outDir, outName);

              let brief = null;

              if (!overwrite && fs.existsSync(outPath)) {
                console.log(`Exists (skip image gen): assets/blog-hero/${outName}`);
              } else {
                // 1) Ask OpenAI to extract keywords + a visual brief from the BLOG TEXT
                console.log(`Brief: week-${pad2(week)} (extract keywords/theme)`);
                brief = await createVisualBrief({ title, metaDesc, bodyText });

                // 2) Use that brief to generate an image prompt
                const imgPrompt = buildImagePromptFromBrief(brief);

                console.log(`Generate: week-${pad2(week)} → ${outName}`);
                const pngBuf = await generateHeroPng(imgPrompt);

                // Convert to web-friendly hero size
                const webpBuf = await toWebpPadded(pngBuf, 1200, 700);
                fs.writeFileSync(outPath, webpBuf);

                // Gentle pacing
                await sleep(900);
              }

              // Update the blog HTML to point at the generated file (relative from /blog/)
              const heroImg = pickHeroImg($);
              const relSrc = `../assets/blog-hero/${outName}`;

              if (heroImg) {
                heroImg.attr("src", relSrc);
                heroImg.attr("loading", "lazy");
                heroImg.attr("decoding", "async");

                // If we generated a brief, use its alt; otherwise keep title-based alt
                const alt = (brief && brief.alt) ? String(brief.alt).trim() : (title || `Week ${pad2(week)} blog hero image`);
                heroImg.attr("alt", alt);

                const updated = $.html();
                if (updated !== html) {
                  fs.writeFileSync(blogPath, updated, "utf8");
                  changedFiles.push(`blog/${file}`);
                }
              } else {
                console.warn(`No <img> found to update in ${file} (image may still exist at assets/blog-hero/${outName})`);
              }

              changedFiles.push(`assets/blog-hero/${outName}`);
            }

            const unique = [...new Set(changedFiles)];
            if (!unique.length) {
              console.log("No changes made.");
            } else {
              console.log(`Changed files (count=${unique.length}):`);
              for (const f of unique) console.log(` - ${f}`);
            }
          })().catch((err) => {
            console.error(err);
            process.exit(1);
          });
          NODE

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          title: "chore(blog): generate hero images (weeks ${{ github.event.inputs.start_week }}–${{ github.event.inputs.end_week }})"
          commit-message: "chore(blog): generate hero images (weeks ${{ github.event.inputs.start_week }}–${{ github.event.inputs.end_week }})"
          branch: "automation/blog-hero-images-${{ github.run_id }}"
          delete-branch: true
          body: |
            Automated hero-image generation for weekly blog posts.

            - Reads each blog post to extract topic keywords + a visual brief (OpenAI text model)
            - Generates images into `assets/blog-hero/week-XX.webp` (OpenAI image model)
            - Updates each blog post to reference its corresponding hero image
            - Uses `OPENAI_API_KEY` from repo secrets
            - No secrets are logged
