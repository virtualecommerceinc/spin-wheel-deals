name: Generate Blog Hero Images

on:
  workflow_dispatch:
    inputs:
      start_week:
        description: "Start week number (1–52)"
        required: true
        default: "1"
      end_week:
        description: "End week number (1–52)"
        required: true
        default: "1"
      overwrite:
        description: "Overwrite existing images (true/false)"
        required: true
        default: "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  generate-images:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          npm init -y
          npm install openai@^4 sharp cheerio

      - name: Generate images + update blog hero img src/alt
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          START_WEEK: ${{ github.event.inputs.start_week }}
          END_WEEK: ${{ github.event.inputs.end_week }}
          OVERWRITE: ${{ github.event.inputs.overwrite }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const cheerio = require("cheerio");
          const sharp = require("sharp");
          const OpenAI = require("openai");

          if (!process.env.OPENAI_API_KEY) {
            console.error("Missing OPENAI_API_KEY secret.");
            process.exit(1);
          }

          const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

          const clampInt = (v, min, max) => {
            const n = Number(String(v).trim());
            if (!Number.isFinite(n)) return min;
            return Math.max(min, Math.min(max, Math.floor(n)));
          };

          const startWeek = clampInt(process.env.START_WEEK, 1, 52);
          const endWeek = clampInt(process.env.END_WEEK, 1, 52);
          const overwrite = String(process.env.OVERWRITE).toLowerCase() === "true";

          const lo = Math.min(startWeek, endWeek);
          const hi = Math.max(startWeek, endWeek);

          const blogDir = path.join(process.cwd(), "blog");
          const outDir = path.join(process.cwd(), "assets", "blog-hero");
          fs.mkdirSync(outDir, { recursive: true });

          const pad2 = (n) => String(n).padStart(2, "0");

          function pickHeroImg($) {
            const candidates = [
              "figure img",
              ".post-hero img",
              ".hero img",
              "header img",
              "main img"
            ];
            for (const sel of candidates) {
              const el = $(sel).first();
              if (el && el.length) return el;
            }
            return null;
          }

          function getTitle($) {
            return (
              ($("h1").first().text() || "").trim() ||
              ($("title").text() || "").trim() ||
              "Dog Blog"
            );
          }

          function htmlToCleanText(html) {
            const $ = cheerio.load(html);

            // Remove junk
            $("script, style, noscript, iframe").remove();
            $("nav, footer, header").remove();

            // Prefer main content if present
            let text = ($("main").text() || "").trim();
            if (!text) text = ($("article").text() || "").trim();
            if (!text) text = ($("body").text() || "").trim();

            // Normalize whitespace
            text = text.replace(/\s+/g, " ").trim();

            // Keep within a safe size for a text call (enough for topic extraction)
            // If your posts are huge, this keeps cost + latency controlled.
            const MAX_CHARS = 6000;
            if (text.length > MAX_CHARS) text = text.slice(0, MAX_CHARS) + "…";

            return text;
          }

          async function sleep(ms) {
            return new Promise((r) => setTimeout(r, ms));
          }

          async function createVisualBrief({ title, blogText }) {
            // Ask a text model to turn the post into a structured, image-ready plan.
            // We keep it strict JSON so we can safely parse it.
            const sys = [
              "You are a senior art director for an evergreen dog blog.",
              "Return ONLY valid JSON. No markdown. No commentary."
            ].join(" ");

            const user = [
              "Create a visual brief for a single hero image that matches this blog post.",
              "Constraints:",
              "- Evergreen dog-themed (no dates, no brands, no celebrity likeness).",
              "- No text in the image (no letters, no watermark, no logo).",
              "- Friendly, semi-realistic illustration (NOT a photo).",
              "- Clean modern style, soft lighting, smooth gradients.",
              "- Composition: centered subject + generous negative space for a header.",
              "- Avoid scary/aggressive imagery unless the post is explicitly about fear/anxiety—and even then keep it gentle.",
              "",
              `BLOG TITLE: ${title}`,
              "",
              "BLOG CONTENT (trimmed):",
              blogText,
              "",
              "Return JSON with exactly these keys:",
              "{",
              '  "visual_concept": "1 sentence describing what the image shows",',
              '  "keywords": ["5-12 short keywords/phrases"],',
              '  "negative": ["things to avoid (5-12 items)"],',
              '  "style_notes": "1-2 sentences describing art style + mood",',
              '  "palette": "short description of colors"',
              "}"
            ].join("\n");

            const resp = await client.chat.completions.create({
              model: "gpt-4o-mini",
              temperature: 0.4,
              messages: [
                { role: "system", content: sys },
                { role: "user", content: user }
              ]
            });

            const raw = resp?.choices?.[0]?.message?.content?.trim() || "";
            let parsed;
            try {
              parsed = JSON.parse(raw);
            } catch (e) {
              // Fallback if the model returns something slightly off:
              // (still keep it deterministic + safe)
              parsed = {
                visual_concept: "A friendly dog interacting with a relevant toy or training scene, matching the blog topic.",
                keywords: ["dog", "training", "toy", "positive reinforcement", "calm", "home"],
                negative: ["text", "logo", "watermark", "brand names", "violent imagery"],
                style_notes: "Friendly semi-realistic illustration, soft lighting, smooth gradients, clean modern look.",
                palette: "cool blues/teals with subtle warm accents"
              };
            }

            // Minimal hardening to avoid weird outputs
            parsed.visual_concept = String(parsed.visual_concept || "").slice(0, 240);
            if (!Array.isArray(parsed.keywords)) parsed.keywords = [];
            if (!Array.isArray(parsed.negative)) parsed.negative = [];

            return parsed;
          }

          function buildImagePrompt({ title, brief }) {
            const lines = [];
            lines.push("Create a clean, modern hero image for a dog blog post.");
            lines.push("Style: friendly, semi-realistic illustration (not a photo), soft lighting, smooth gradients, high clarity.");
            lines.push("No text, no letters, no watermarks, no logos.");
            lines.push("Centered composition with generous negative space (wide header).");
            lines.push(`Topic/title: ${title}`);
            if (brief?.visual_concept) lines.push(`Visual concept: ${brief.visual_concept}`);
            if (brief?.style_notes) lines.push(`Style notes: ${brief.style_notes}`);
            if (brief?.palette) lines.push(`Palette: ${brief.palette}`);
            if (brief?.keywords?.length) lines.push(`Keywords: ${brief.keywords.slice(0, 12).join(", ")}`);
            if (brief?.negative?.length) lines.push(`Avoid: ${brief.negative.slice(0, 12).join(", ")}`);
            return lines.join("\n");
          }

          async function generateHeroPng(prompt) {
            const res = await client.images.generate({
              model: "gpt-image-1-mini",
              prompt,
              size: "1536x1024",
              quality: "low"
            });

            const b64 = res?.data?.[0]?.b64_json;
            if (!b64) throw new Error("No b64_json returned from image generation.");
            return Buffer.from(b64, "base64");
          }

          function toWebpPadded(inputPngBuffer, width, height) {
            return sharp(inputPngBuffer)
              .resize(width, height, { fit: "contain", background: { r: 0, g: 0, b: 0, alpha: 0 } })
              .webp({ quality: 82 })
              .toBuffer();
          }

          (async () => {
            console.log(`Generating hero images for weeks ${lo}–${hi} (overwrite=${overwrite})`);
            const changedFiles = new Set();

            for (let week = lo; week <= hi; week++) {
              const file = `week-${pad2(week)}.html`;
              const blogPath = path.join(blogDir, file);

              if (!fs.existsSync(blogPath)) {
                console.warn(`Skip: ${blogPath} not found`);
                continue;
              }

              const html = fs.readFileSync(blogPath, "utf8");
              const $ = cheerio.load(html);

              const title = getTitle($);
              const blogText = htmlToCleanText(html);

              const outName = `week-${pad2(week)}.webp`;
              const outPath = path.join(outDir, outName);

              if (!overwrite && fs.existsSync(outPath)) {
                console.log(`Exists (skip): assets/blog-hero/${outName}`);
              } else {
                console.log(`Planning image: week-${pad2(week)}`);
                const brief = await createVisualBrief({ title, blogText });

                const prompt = buildImagePrompt({ title, brief });
                console.log(`Generate: week-${pad2(week)} → ${outName}`);

                const pngBuf = await generateHeroPng(prompt);
                const webpBuf = await toWebpPadded(pngBuf, 1200, 700);
                fs.writeFileSync(outPath, webpBuf);

                changedFiles.add(`assets/blog-hero/${outName}`);

                // pacing (keeps the job polite + reliable)
                await sleep(900);
              }

              const heroImg = pickHeroImg($);
              const relSrc = `../assets/blog-hero/${outName}`;

              if (heroImg) {
                heroImg.attr("src", relSrc);
                heroImg.attr("loading", "lazy");
                heroImg.attr("decoding", "async");
                heroImg.attr("alt", title || `Week ${pad2(week)} blog hero image`);

                const updated = $.html();
                if (updated !== html) {
                  fs.writeFileSync(blogPath, updated, "utf8");
                  changedFiles.add(`blog/${file}`);
                }
              } else {
                console.warn(`No <img> found to update in ${file} (image still generated).`);
              }
            }

            if (changedFiles.size === 0) {
              console.log("No changes made.");
            } else {
              console.log(`Changed files (count=${changedFiles.size}):`);
              for (const f of changedFiles) console.log(` - ${f}`);
            }
          })().catch((err) => {
            console.error(err);
            process.exit(1);
          });
          NODE

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          title: "chore(blog): generate hero images (weeks ${{ github.event.inputs.start_week }}–${{ github.event.inputs.end_week }})"
          commit-message: "chore(blog): generate hero images (weeks ${{ github.event.inputs.start_week }}–${{ github.event.inputs.end_week }})"
          branch: "automation/blog-hero-images-${{ github.run_id }}"
          delete-branch: true
          body: |
            Automated hero-image generation for weekly blog posts.

            - Generates images into `assets/blog-hero/week-XX.webp`
            - Updates each blog post to reference its corresponding hero image
            - Uses `OPENAI_API_KEY` from repo secrets
